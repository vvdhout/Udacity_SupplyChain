pragma solidity ^0.5.1;

import '../AccessControl/AccessControl.sol';
import '../Core/Ownable.sol';

// Define a contract 'Supplychain'
contract SupplyChain is AccessControl, Ownable {

  // Define a variable called 'upc' for Universal Product Code (UPC)
  uint  upc;

  // Define a variable called 'sku' for Stock Keeping Unit (SKU)
  uint  sku;

  // Define a public mapping 'items' that maps the UPC to an Item.
  mapping (uint => Item) items;

  // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, 
  // that track its journey through the supply chain -- to be sent from DApp.
  mapping (uint => string[]) itemsHistory;
  
  // Define enum 'State' with the following values:
  enum State 
  { 
    Harvested,                  // 0
    Processed,                  // 1
    Packaged,                   // 2
    ForSale,                    // 3
    Sold,                       // 4
    Shipped,                    // 5
    Received,                   // 6
    Manufactured,               // 7
    PackagedByManufacturer,     // 8
    ForSaleByManufacturer,      // 9
    SoldByManufacturer,         // 10
    ShippedByManufacturer,      // 11
    ForSaleByDistributor,       // 12
    SoldByDistributor,          // 13
    ShippedByDistributor,       // 14
    ForSaleByRetailer,          // 15
    Purchased,                  // 16
    ShippedByRetailer,          // 17
    ReceivedByConsumer          // 18
    }
    
  // And a Material State enum 
    enum MaterialState {
        Lumber,     // 1
        Product     // 2
    }

  State constant defaultState = State.Harvested;
  MaterialState constant defaultMaterialState = MaterialState.Lumber;

  // Define a struct 'Item' with the following fields:
  struct Item {
    uint    sku;  // Stock Keeping Unit (SKU)
    uint    upc; // Universal Product Code (UPC), generated by the Harvester, goes on the package, can be verified by the Consumer
    address payable ownerID;  // Metamask-Ethereum address of the current owner as the product moves through 18 stages
    address payable originHarvesterID; // Metamask-Ethereum address of the Harvester
    string  originHarvesterName; // Harvester Name
    string  originHarvesterInformation;  // Harvester Information
    string  originHarvesterLatitude; // Harvester Latitude
    string  originHarvesterLongitude;  // Harvester Longitude
    uint    productID;  // Product ID potentially a combination of upc + sku
    string  productNotes; // Product Notes
    uint    productPrice; // Product Price
    State   itemState;  // Product State as represented in the enum above
    MaterialState itemState2; // Material State of the product as represented by the enum above
    address payable manufacturerID; // Metamask-Ethereum address of the Manufacturer
    string  productNotesByManufacturer; // Product notes that are added by the Manufacturer
    address payable distributorID;  // Metamask-Ethereum address of the Distributor
    address payable retailerID; // Metamask-Ethereum address of the Retailer
    address payable consumerID; // Metamask-Ethereum address of the Consumer
  }

  // Define 18 events with the same 18 state values and accept 'upc' as input argument
    event Harvested (uint upc);          
    event Processed (uint upc);            
    event Packaged (uint upc);                
    event ForSale  (uint upc);              
    event Sold (uint upc);                 
    event Shipped (uint upc);               
    event Received (uint upc);                
    event Manufactured (uint upc);           
    event PackagedByManufacturer (uint upc);   
    event ForSaleByManufacturer (uint upc);    
    event SoldByManufacturer (uint upc);      
    event ShippedByManufacturer (uint upc);   
    event ForSaleByDistributor (uint upc);    
    event SoldByDistributor (uint upc);      
    event ShippedByDistributor (uint upc);       
    event ForSaleByRetailer (uint upc);           
    event Purchased (uint upc);                
    event ShippedByRetailer (uint upc);          
    event ReceivedByConsumer (uint upc);                     

  // Define a modifer that verifies the Caller
  modifier verifyCaller (address _address) {
    require(msg.sender == _address); 
    _;
  }

  // Define a modifier that checks if the paid amount is sufficient to cover the price
  modifier paidEnough(uint _price) { 
    require(msg.value >= _price); 
    _;
  }
  
  // Define a modifier that checks the price and refunds the remaining balance
  modifier checkValue(uint _upc) {
    _;
    uint _price = items[_upc].productPrice;
    uint amountToReturn = msg.value - _price;
    items[_upc].ownerID.transfer(amountToReturn);
  }

  // Define a modifier that checks if an item.state of a upc is Harvested
  modifier harvested(uint _upc) {
    require(items[_upc].itemState == State.Harvested);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Processed
  modifier processed(uint _upc) {
      require(items[_upc].itemState == State.Processed);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Packed
  modifier packaged(uint _upc) {
      require(items[_upc].itemState == State.Packaged);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is ForSale
  modifier forSale(uint _upc) {
      require(items[_upc].itemState == State.ForSale);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Sold
  modifier sold(uint _upc) {
      require(items[_upc].itemState == State.Sold);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Shipped
  modifier shipped(uint _upc) {
      require(items[_upc].itemState == State.Shipped);
    _;
  }

  // Define a modifier that checks if an item.state of a upc is Received
  modifier received(uint _upc) {
      require(items[_upc].itemState == State.Received);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Manufactured
  modifier manufactured(uint _upc) {
      require(items[_upc].itemState == State.Manufactured);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is PackagedByManufacturer
  modifier packagedByManufacturer(uint _upc) {
      require(items[_upc].itemState == State.PackagedByManufacturer);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ForSaleByManufacturer
  modifier forSaleByManufacturer(uint _upc) {
      require(items[_upc].itemState == State.ForSaleByManufacturer);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is SoldByManufacturer
  modifier soldByManufacturer(uint _upc) {
      require(items[_upc].itemState == State.SoldByManufacturer);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ShippedByManufacturer
  modifier shippedByManufacturer(uint _upc) {
      require(items[_upc].itemState == State.ShippedByManufacturer);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ForSaleByDistributor
  modifier forSaleByDistributor(uint _upc) {
      require(items[_upc].itemState == State.ForSaleByDistributor);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is SoldByDistributor
  modifier soldByDistributor(uint _upc) {
      require(items[_upc].itemState == State.SoldByDistributor);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ShippedByDistributor
  modifier shippedByDistributor(uint _upc) {
      require(items[_upc].itemState == State.ShippedByDistributor);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ForSaleByRetailer
  modifier forSaleByRetailer(uint _upc) {
      require(items[_upc].itemState == State.ForSaleByRetailer);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is Purchased
  modifier purchased(uint _upc) {
      require(items[_upc].itemState == State.Purchased);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ShippedByRetailer
  modifier shippedByRetailer(uint _upc) {
      require(items[_upc].itemState == State.ShippedByRetailer);
    _;
  }
  
  // Define a modifier that checks if an item.state of a upc is ReceivedByConsumer
  modifier receivedByConsumer(uint _upc) {
      require(items[_upc].itemState == State.ReceivedByConsumer);
    _;
  }
  

  // In the constructor
  // set 'sku' to 1
  // and set 'upc' to 1
  constructor() public payable {
    sku = 1;
    upc = 1;
  }

  // Define a function 'kill' if required
  function kill() public {
    if (msg.sender == owner()) {
      selfdestruct(msg.sender);
    }
  }
  

  // Define a function 'harvestLumber' that allows a harvester to mark an item 'Harvested'
  function harvestLumber(uint _upc, address _originHarvesterID, string memory _originHarvesterName, string memory _originHarvesterInformation, string memory _originHarvesterLatitude, string  memory _originHarvesterLongitude, string memory _productNotes) public 
  
  verifyCaller(_originHarvesterID) //VerifyCaller 
  onlyHarvester() // onlyHarvester()
  {
    // Require that the UPC does not already exist
    require(_upc != 0 && items[_upc].upc == 0, "This UPC already exists.");
    // Add the new item as part of Harvest
    Item memory newItem;
    newItem.sku = sku;
    newItem.upc = _upc;
    newItem.ownerID = msg.sender;
    newItem.originHarvesterID = msg.sender;
    newItem.originHarvesterName = _originHarvesterName;
    newItem.originHarvesterInformation = _originHarvesterInformation;
    newItem.originHarvesterLatitude = _originHarvesterLatitude;
    newItem.originHarvesterLongitude = _originHarvesterLongitude;
    newItem.productNotes = _productNotes;
    newItem.productID = _upc + 1000000000000000;
    newItem.itemState = State.Harvested;
    newItem.itemState2 = MaterialState.Lumber;
    
    // Add item to mapping using UFC
    items[_upc] = newItem;
    
    // Increment sku
    sku = sku + 1;
    
    // Emit the appropriate event
    emit Harvested(_upc);
    
  }

  // Define a function 'processLumber' that allows a harvester to mark an item 'Processed'
  function processLumber(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  harvested(_upc)
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].originHarvesterID)
  // Only harvester can process 
  onlyHarvester()
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Processed;

    // Emit the appropriate event
    emit Processed(_upc);
  }

  // Define a function 'pakacgeLumber' that allows a harvester to mark an item 'Packaged'
  function packageLumber(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  processed(_upc)
  // Only harvester
  onlyHarvester()
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].originHarvesterID)
  {
    // Update the appropriate fields
    items[_upc].itemState = State.Packaged;

    // Emit the appropriate event
    emit Packaged(_upc);
  }

  // Define a function 'sellLumber' that allows a harvester to mark an item 'ForSale'
  function sellLumber(uint _upc, uint _price) public 
  // Call modifier to check if upc has passed previous supply chain stage
  packaged(_upc)
  // Only harvester
  onlyHarvester()
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].originHarvesterID)
  {
    // Update the appropriate fields
    items[_upc].productPrice = _price;
    items[_upc].itemState = State.ForSale;

    // Emit the appropriate event
    emit ForSale(_upc);
  }

  // Define a function 'buyItem' that allows the disributor to mark an item 'Sold'
  // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyLumber(uint _upc) public payable 
    // Call modifier to check if upc has passed previous supply chain stage
    forSale(_upc)
    // Only manufacturer
    onlyManufacturer()
    // Call modifer to check if buyer has paid enough
    paidEnough(items[_upc].productPrice)
    // Call modifer to send any excess ether back to buyer
    checkValue(_upc)
    {
    
    // Update the appropriate fields - ownerID, distributorID, itemState
    items[_upc].ownerID = msg.sender;
    items[_upc].manufacturerID = msg.sender;
    items[_upc].itemState = State.Sold;
    // Transfer money to farmer
    items[_upc].originHarvesterID.transfer(items[_upc].productPrice);
    // emit the appropriate event
    emit Sold(_upc);
  }

  // Define a function 'shipItem' that allows the distributor to mark an item 'Shipped'
  // Use the above modifers to check if the item is sold
  function shipLumber(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    sold(_upc)
    // Only harvester
    onlyHarvester()
    // Call modifier to verify caller of this function
    verifyCaller(items[_upc].originHarvesterID)
    {
    // Update the appropriate fields
    items[_upc].itemState = State.Shipped;
    
    // Emit the appropriate event
    emit Shipped(_upc);
  }

  // Define a function 'receiveItem' that allows the manufacturer to mark an item 'Received'
  // Use the above modifiers to check if the item is shipped
  function receiveLumber(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    shipped(_upc)
    // Only manufacturer 
    onlyManufacturer()
    // Access Control List enforced by calling Smart Contract / DApp
    verifyCaller(items[_upc].manufacturerID)
    {
    // Update the appropriate fields - ownerID, retailerID, itemState
    items[_upc].itemState = State.Received;
    
    // Emit the appropriate event
    emit Received(_upc); 
  }
  
  // Manufacture the product by mananufacturer
  function manufactureProduct(uint _upc, string memory _manufacturerNotes) public
  // Call modifier to check if upc has passed previous supply chain stage
  received(_upc)
  // Only manufacturer 
    onlyManufacturer()
  // Verify manufacturer
  verifyCaller(items[_upc].ownerID)
  {
      // Change item states accordingly
      items[_upc].itemState = State.Manufactured;
      items[_upc].itemState2 = MaterialState.Product;
      items[_upc].productNotesByManufacturer = _manufacturerNotes;
      
      // Emit event
      emit Manufactured(_upc);
  }
  
  // Allow packaging of product by Manufacturer
  function packageProduct(uint _upc) public 
  // Call modifier to check if upc has passed previous supply chain stage
  manufactured(_upc)
  // Only manufacturer 
    onlyManufacturer()
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].ownerID)
  {
    // Update the appropriate fields
    items[_upc].itemState = State.PackagedByManufacturer;

    // Emit the appropriate event
    emit PackagedByManufacturer(_upc);
  }
  
 
  // Allow selling of product by Manufacturer
  function sellProductByManufacturer(uint _upc, uint _price) public 
  // Call modifier to check if upc has passed previous supply chain stage
  packagedByManufacturer(_upc)
  // Only manufacturer 
    onlyManufacturer()
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].ownerID)
  {
    // Update the appropriate fields
    items[_upc].productPrice = _price;
    items[_upc].itemState = State.ForSaleByManufacturer;

    // Emit the appropriate event
    emit ForSaleByManufacturer(_upc);
  }

  // Define a function 'buyProduct' that allows the distributor
  // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyProductByDistributor(uint _upc) public payable 
    // Call modifier to check if upc has passed previous supply chain stage
    forSaleByManufacturer(_upc)
    // Only distributor
    onlyDistributor()
    // Call modifer to check if buyer has paid enough
    paidEnough(items[_upc].productPrice)
    // Call modifer to send any excess ether back to buyer
    checkValue(_upc)
    {
    
    // Update the appropriate fields - ownerID, distributorID, itemState
    items[_upc].ownerID = msg.sender;
    items[_upc].distributorID = msg.sender;
    items[_upc].itemState = State.SoldByManufacturer;
    // Transfer money to farmer
    items[_upc].manufacturerID.transfer(items[_upc].productPrice);
    // emit the appropriate event
    emit SoldByManufacturer(_upc);
  }

  // Allow shipping of product by Manufacturer
  // Use the above modifers to check if the item is sold
  function shipProductByManufacturer(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    soldByManufacturer(_upc)
    // Only manufacturer 
    onlyManufacturer()
    // Call modifier to verify caller of this function
    verifyCaller(items[_upc].manufacturerID)
    {
    // Update the appropriate fields
    items[_upc].itemState = State.ShippedByManufacturer;
    
    // Emit the appropriate event
    emit ShippedByManufacturer(_upc);
  }
  
  
  // Allow selling of product by distributor
  function sellProductByDistributor(uint _upc, uint _price) public 
  // Call modifier to check if upc has passed previous supply chain stage
  shippedByManufacturer(_upc)
  // Only distributor
    onlyDistributor()
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].ownerID)
  {
    // Update the appropriate fields
    items[_upc].productPrice = _price;
    items[_upc].itemState = State.ForSaleByDistributor;

    // Emit the appropriate event
    emit ForSaleByDistributor(_upc);
  }

  // Allow buying of product by retailer
  // Use the above defined modifiers to check if the item is available for sale, if the buyer has paid enough, 
  // and any excess ether sent is refunded back to the buyer
  function buyProductByRetailer(uint _upc) public payable 
    // Call modifier to check if upc has passed previous supply chain stage
    forSaleByDistributor(_upc)
    // Only Retailer
    onlyRetailer()
    // Call modifer to check if buyer has paid enough
    paidEnough(items[_upc].productPrice)
    // Call modifer to send any excess ether back to buyer
    checkValue(_upc)
    {
    
    // Update the appropriate fields - ownerID, distributorID, itemState
    items[_upc].ownerID = msg.sender;
    items[_upc].retailerID = msg.sender;
    items[_upc].itemState = State.SoldByDistributor;
    // Transfer money to farmer
    items[_upc].distributorID.transfer(items[_upc].productPrice);
    // emit the appropriate event
    emit SoldByDistributor(_upc);
  }

  // Allow shipping of product by distributor
  // Use the above modifers to check if the item is sold
  function shipProductByDistributor(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    soldByDistributor(_upc)
    // Only distributor
    onlyDistributor()
    // Call modifier to verify caller of this function
    verifyCaller(items[_upc].distributorID)
    {
    // Update the appropriate fields
    items[_upc].itemState = State.ShippedByDistributor;
    
    // Emit the appropriate event
    emit ShippedByDistributor(_upc);
  }
  
  // Allow selling of product by retailer
  function sellProductByRetailer(uint _upc, uint _price) public 
  // Call modifier to check if upc has passed previous supply chain stage
  shippedByDistributor(_upc)
  // Only Retailer
    onlyRetailer()
  // Call modifier to verify caller of this function
  verifyCaller(items[_upc].ownerID)
  {
    // Update the appropriate fields
    items[_upc].productPrice = _price;
    items[_upc].itemState = State.ForSaleByRetailer;

    // Emit the appropriate event
    emit ForSaleByRetailer(_upc);
  }

  // Define a function 'purchase' that allows the consumer to mark an item 'Purchased'
  // Use the above modifiers to check if the item is received
  function purchase(uint _upc) public payable
    // Call modifier to check if upc has passed previous supply chain stage
    forSaleByRetailer(_upc)
    // Only consumer 
    onlyConsumer()
    // Access Control List enforced by calling Smart Contract / DApp
    // Call modifer to check if buyer has paid enough
    paidEnough(items[_upc].productPrice)
    // Call modifer to send any excess ether back to buyer
    checkValue(_upc)
    {
   // Update the appropriate fields - ownerID, distributorID, itemState
    items[_upc].ownerID = msg.sender;
    items[_upc].consumerID = msg.sender;
    items[_upc].itemState = State.Purchased;
    // Transfer money to farmer
    items[_upc].retailerID.transfer(items[_upc].productPrice);
    // emit the appropriate event
    emit Purchased(_upc);
    
  }
  
  // Allow shippinh of product by retailer
  // Use the above modifers to check if the item is sold
  function shipProductByRetailer(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    purchased(_upc)
    // Only Retailer
    onlyRetailer()
    // Call modifier to verify caller of this function
    verifyCaller(items[_upc].retailerID)
    {
    // Update the appropriate fields
    items[_upc].itemState = State.ShippedByRetailer;
    
    // Emit the appropriate event
    emit ShippedByRetailer(_upc);
  }
  
  // Allow receiving of product by consumer
  // Use the above modifiers to check if the item is shipped
  function receiveProduct(uint _upc) public 
    // Call modifier to check if upc has passed previous supply chain stage
    shippedByRetailer(_upc)
    // Only consumer 
    onlyConsumer()
    // Access Control List enforced by calling Smart Contract / DApp
    verifyCaller(items[_upc].ownerID)
    {
    // Update the appropriate fields - ownerID, retailerID, itemState
    items[_upc].itemState = State.ReceivedByConsumer;
    
    // Emit the appropriate event
    emit ReceivedByConsumer(_upc); 
  }
  

  // Define a function 'fetchItemBufferOne' that fetches the data
  function fetchItemBufferOne(uint _upc) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  address ownerID,
  address originHarvesterID,
  string memory originHarvesterName,
  string memory originHarvesterInformation,
  string memory originHarvesterLatitude,
  string memory originHarvesterLongitude
  ) 
  {
  // Assign values to the 8 parameters
  Item memory returnItem = items[_upc];
    
  return 
  (
  returnItem.sku,
  returnItem.upc,
  returnItem.ownerID,
  returnItem.originHarvesterID,
  returnItem.originHarvesterName,
  returnItem.originHarvesterInformation,
  returnItem.originHarvesterLatitude,
  returnItem.originHarvesterLongitude
  );
  }

  // Define a function 'fetchItemBufferTwo' that fetches the data
  function fetchItemBufferTwo(uint _upc) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  uint    productID,
  string memory productNotes,
  string memory productNotesByManufacturer,
  uint    productPrice,
  State   itemState,
  MaterialState    itemState2,
  address payable manufacturerID,
  address payable distributorID,
  address payable retailerID,
  address payable consumerID
  ) 
  {
    // Assign values to the 9 parameters
  Item memory returnItem = items[_upc];
    
  return 
  (
  returnItem.sku,
  returnItem.upc,
  returnItem.productID,
  returnItem.productNotes,
  returnItem.productNotesByManufacturer,
  returnItem.productPrice,
  returnItem.itemState,
  returnItem.itemState2,
  returnItem.manufacturerID,
  returnItem.distributorID,
  returnItem.retailerID,
  returnItem.consumerID
  );
  }
}